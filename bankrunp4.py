# -*- coding: utf-8 -*-
"""BankRunP4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rui-Ln3FRGN3hGiuApyW5t9rTqY--DrL
"""

import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class Customer:
    def __init__(self, name, initial_deposit):
        self.name = name
        self.deposit = initial_deposit
        self.withdrawn = False
        self.trust_level = random.uniform(0.5, 1.0)  # Random initial trust
        self.neighbors = []
        self.cash = 0

    def decide_withdrawal(self, bank, rumor_strength):
        if self.withdrawn:
            return False

        # Calculate neighbor influence
        neighbor_withdrawal_ratio = 0
        if self.neighbors:
            withdrawals = sum(1 for n in self.neighbors if n.withdrawn)
            neighbor_withdrawal_ratio = withdrawals / len(self.neighbors)

        # Decision factors
        panic_threshold = self.trust_level - (rumor_strength * 0.3) - (neighbor_withdrawal_ratio * 0.4)

        # Make withdrawal decision
        will_withdraw = random.random() > panic_threshold

        if will_withdraw and bank.process_withdrawal(self):
            self.withdrawn = True
            self.cash = self.deposit
            self.deposit = 0
            return True
        return False

class Bank:
    def __init__(self, initial_reserve_ratio=0.3):
        self.deposits = 0
        self.reserves = 0
        self.reserve_ratio = initial_reserve_ratio
        self.failed = False

    def add_deposit(self, amount):
        self.deposits += amount
        self.reserves += amount * self.reserve_ratio

    def process_withdrawal(self, customer):
        if self.reserves >= customer.deposit:
            self.reserves -= customer.deposit
            self.deposits -= customer.deposit
            return True
        else:
            self.failed = True
            return False


def simulate_bank_run(num_customers=100, num_timesteps=20):
    # Initialize bank and customers
    bank = Bank()
    customers = []

    # Create customers with random initial deposits
    for i in range(num_customers):
        deposit = random.uniform(1000, 5000)
        customer = Customer(f"Customer_{i}", deposit)
        customers.append(customer)
        bank.add_deposit(deposit)

    # Assign random neighbors to each customer
    for customer in customers:
        num_neighbors = random.randint(3, 7)
        customer.neighbors = random.sample([c for c in customers if c != customer], num_neighbors)

    # Track metrics over time
    history = {
        'timestep': [],
        'total_withdrawals': [],
        'bank_reserves': [],
        'bank_deposits': [],
        'withdrawal_rate': []
    }

    # Run simulation
    for t in range(num_timesteps):
        print(f"\n--- Time Step {t + 1} ---")

        # Increase rumor strength over time
        base_rumor = 0.1
        rumor_strength = min(base_rumor + (t * 0.05), 0.8)

        # Process customer decisions
        withdrawals_this_step = 0
        for customer in customers:
            if customer.decide_withdrawal(bank, rumor_strength):
                withdrawals_this_step += 1
                print(f"{customer.name} withdrew {customer.cash:.2f}")

                # Print neighbor influence
                withdrawn_neighbors = sum(1 for n in customer.neighbors if n.withdrawn)
                print(f"  Influenced by {withdrawn_neighbors}/{len(customer.neighbors)} neighbors who withdrew")
                print(f"  Trust level: {customer.trust_level:.2f}")

        # Log metrics
        total_withdrawals = sum(1 for c in customers if c.withdrawn)
        withdrawal_rate = withdrawals_this_step / num_customers

        print(f"\nStep Summary:")
        print(f"New withdrawals: {withdrawals_this_step}")
        print(f"Bank reserves: {bank.reserves:.2f}")
        print(f"Bank deposits: {bank.deposits:.2f}")
        print(f"Rumor strength: {rumor_strength:.2f}")

        # Store history
        history['timestep'].append(t + 1)
        history['total_withdrawals'].append(total_withdrawals)
        history['bank_reserves'].append(bank.reserves)
        history['bank_deposits'].append(bank.deposits)
        history['withdrawal_rate'].append(withdrawal_rate)

        if bank.failed:
            print("\nBANK HAS FAILED - Simulation ended")
            break

    return history, bank, customers

def run_and_visualize():
    history, bank, customers = simulate_bank_run()

    # Calculate key statistics
    max_withdrawals = max(history['total_withdrawals'])
    final_reserves = history['bank_reserves'][-1]
    final_deposits = history['bank_deposits'][-1]
    initial_deposits = history['bank_deposits'][0]
    reserve_ratio = (final_reserves / final_deposits) * 100
    total_deposits_lost = initial_deposits - final_deposits

    # Create figure with more space for annotations
    plt.figure(figsize=(15, 10))

    # Plot withdrawals over time with stats
    plt.subplot(2, 1, 1)
    plt.plot(history['timestep'], history['total_withdrawals'], 'r-', label='Total Withdrawals')
    plt.title('Bank Run Progression', pad=20)
    plt.xlabel('Time Step')
    plt.ylabel('Number of Withdrawals')

    # Add statistical annotations
    stats_text = f'Peak Withdrawals: {max_withdrawals:,.0f}\n'
    plt.annotate(stats_text, xy=(0.02, 0.95), xycoords='axes fraction',
                bbox=dict(facecolor='white', alpha=0.8, edgecolor='none'))

    # Add grid for better readability
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.legend()

    # Plot bank reserves and deposits with stats
    plt.subplot(2, 1, 2)
    plt.plot(history['timestep'], history['bank_reserves'], 'g-', label='Bank Reserves')
    plt.plot(history['timestep'], history['bank_deposits'], 'b-', label='Bank Deposits')
    plt.title('Bank Financial Status', pad=20)
    plt.xlabel('Time Step')
    plt.ylabel('Amount')

    # Add financial statistics
    financial_stats = (
        f'Final Reserve Ratio: {reserve_ratio:.1f}%\n'
        f'Final Reserves: ${final_reserves:,.0f}\n'
        f'Total Deposits Lost: ${total_deposits_lost:,.0f}'
    )
    plt.annotate(financial_stats, xy=(0.02, 0.95), xycoords='axes fraction',
                bbox=dict(facecolor='white', alpha=0.8, edgecolor='none'))

    # Add grid for better readability
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.legend()

    # Improve layout
    plt.tight_layout(h_pad=3.0)  # Add more space between subplots

    # Add a super title with simulation summary
    plt.suptitle('Bank Run Simulation Results', y=1.02, fontsize=16)

    plt.show()

    return history, bank, customers

run_and_visualize()